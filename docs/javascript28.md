---
id: javascript000000
title: Регулярные выражения
sidebar_label: Регулярные выражения
---

**Регулярные выражения** (англ. _regular expressions_) — формальный язык поиска и осуществления манипуляций с строками в тексте, основанный на использовании метасимволов. Регулярные выражения позволяют:
* **Искать** текст в строке;
* **Заменять** подстроки в строке;
* **Извлекать** информацию из строки.

JavaScript, наряду с Perl, это один из языков программирования, в котором поддержка регулярных выражений встроена непосредственно в язык.

## Сложность использования

Недостаток регулярных выражений в том, что часто они выглядят странно и даже пугающе. Особенно это касается более сложных шаблонов. 

```jsx 
  let regExp = /^[a-zA-Z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/
```

## Определение регулярных выражения

Определение регулярного выражения, это создание шаблона, на основе которого будет происходить работа со строками. В JavaScript регулярные выражения - это объект, который может быть определён двумя способами.

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs
  defaultValue="literal"
  values={[
      {label: 'Литерал', value: 'literal'},
      {label: 'Конструкция', value: 'construction'},
    ]
  }>
  <TabItem value="literal">

  Определение регулярных выражений с использованием литералов. Для регулярных выражений литералами выступают слэши `/ ... /`, они играют ту же роль, что и `' ... '` при создании строк.

  ```jsx
    let regExp = /шаблон/
  ```

  Если вы решили создавать регулярные выражения при помощи литералов, то стоит учитывать, что такой метод создания _не допускает динамическое изменение_ задаваемых значений. Происходит это из-за того, что литералы регулярных выражения вызывают _предварительную компиляцию_ при анализе скрипта. 

  </TabItem>
  <TabItem value="construction">

  Определение регулярных выражений с использованием конструктора.

  ```jsx
    let regExp = new RegExp('шаблон')
  ```
  Компиляция регулярного выражения созданного с использованием конструктора происходит в момент выполнения скрипта. Такой способ создания стоит использовать, если ваше регулярное выражение создаётся их динамически сгенерированной строки.

  </TabItem>
</Tabs>

## Использование

Использование регулярных выражений рассмотрим на примере:
```jsx
  let regExp = /banana/
```

Этим кодом мы создали просто регулярное выражение, которое ищет строку `banana`. Для тестирования регулярного выражения можно использовать метод `.test(string)`, результатом работы метода является `boolean` значение.

```jsx live
function learnJavaScript() {
  let regExp = /banana/,
  str = 'fanana ranana banana'
  return regExp.test(str) ? 'Нашёл' : 'Нету'
}
```

В примере регулярное выражение ищет подстроку `banana` в строке `str`.

## Флаги

Флаги используются для расширения осуществляемого регулярными выражениями поиска. 

- `g` - при поиске ищет все совпадения;
- `i` - поиск не зависит от регистра `[Z-z]`;
- `m` - многострочный режим;
- `s` - включает режим **dotall**, при котором точка `.` может соответствовать символу перевода строки;
- `y` - выполняет поиск начиная с символа, который находится на позиции свойства **lastindex** текущего регулярного выражения;
- `u` - включает поддержку **Unicode**.

Использование флагов при разных способах создания шаблона регулярного выражения
<Tabs
  defaultValue="literal"
  values={[
      {label: 'Литерал', value: 'literal'},
      {label: 'Конструкция', value: 'construction'},
    ]
  }>
  <TabItem value="literal">

  ```jsx
    let regExp = /шаблон/флаг
  ```
  Обратите внимание, что флаги являются **неотъемлемой частью** регулярного выражения. Флаги не могут быть добавлены или удалены позднее. Так же флаги можно комбинировать.

  ```jsx live
    function learnJavaScript() {
      let regExp = /banana/i,
      str = 'faNana RanaNA BaNanA'
      return regExp.test(str) ? 'Нашёл' : 'Нету'
    }
  ```

  Попробуйте убрать флаг `i` из примера.
  </TabItem>
  <TabItem value="construction">

   ```jsx
    let regExp = new RegExp('шаблон', 'флаг')
   ``` 

   Обратите внимание, что флаги являются **неотъемлемой частью** регулярного выражения. Флаги не могут быть добавлены или удалены позднее. Так же флаги можно комбинировать.

  ```jsx live
    function learnJavaScript() {
      let regExp = new RegExp('banana', 'i'),
      str = 'faNana RanaNA BaNanA'
      return regExp.test(str) ? 'Нашёл' : 'Нету'
    }
  ```

  Попробуйте убрать флаг `i` из примера.
  </TabItem>
</Tabs>

## Символьные классы

**Символьный класс** - это специальное обозначение, которое соответствует любому символу из определённого набора. Символьный класс обозначается обратным слэшом `\`, символ последующий после слэша будет считаться специальным символом. Специальные символы используются для создания более сложных шаблонов.

Наиболее часто используемые специальные символы регулярных выражений в JavaScript:
#### `.` - соответствует любому символу
```jsx
let regExp = /шабло./
// На месте точки может находиться любой символ
```

#### `\d` - соответствует цифре от 0 до 9
```jsx
let regExp = /\d/
// `3` в `ban3ana`
// `4` в `in 412`
```

#### `\w` - соответствует букве латинского алфавита, цифре и подчёркиванию `_`
```jsx
let regExp = /\w/
// `1` в `№1`
// `b` в `banana*`
```

#### `\s` - соответствует одиночному символу пустого пространства (пробел, табуляция, перевод строки)
```jsx
let regExp = /\s/
// ' ' в `lime orange` 
```
#### `\0` - соответствует `null`

#### `\n` - соответствует символу перевода строки

#### `\t` - соответствует символу горизонтальной табуляции

#### `\v` - соответствует символу вертикальной табуляции

#### `\r` - соответствует символу возврата каретки

#### `\xhh` - соответствует символам кода hh (две шестнадцатеричные цифры)

#### `\uhhhh`	- соответствует символам кода hhhh (четыре шестнадцатеричные цифры)

### Обратные символьные классы

Для некоторых символьных классов существует `обратный класс`, который обозначается такой же буквой, но в верхнем регистре. Этот класс выдаёт `противоположное значение` исходному, символьному классу.

#### `\D` - всё, что не соответствует `\d`
```jsx
let regExp = /\D/
// `b` в `ban3ana`
// `i` в `in 412`
```

#### `\W` - всё, что не соответствует `\w`
```jsx
let regExp = /\W/
// `№` в `№1`
// `*` в `banana*`
```

#### `\S` - всё, что не соответствует `\s`
```jsx
let regExp = /\s/
// `l` в `lime orange`
```

## Якоря

Якоря привязывают шаблон к началу или концу строки. Для привязки к началу строки используется - `^`, а к концу - `$`.

```jsx live
function learnJavaScript() {
  let regExp = /^banana/,
  str = 'lime banana orange'
  return regExp.test(str) ? 'Нашёл' : 'Нету'
}
```

Используя такой шаблон `/banana/` вы будете искать `banana` во всей строке. Если нужно проверить на полное совпадение строки с шаблоном нужно использовать якоря `/^banana$/`. Метод `.test()` вернёт `true` только в том случае, если вся строка это `banana`.

## Экранирование

Если вам нужно в шаблоне использовать символ, который является специальным, то его нужно **экранировать**. Для экранирования используют обратный слэш `\`.

```jsx live
function learnJavaScript() {
  let regExp = /banana\./,
  str = 'lime orange banana.'
  return regExp.test(str) ? 'Нашёл' : 'Нету'
}
```

## Диапазоны и наборы

Для поиска определенных символов из диапазона или набора их нужно указать в квадратных скобках `[...]`. К примеру, нужно найти в строке цифру 1, 5 или 8. Такому набору будет соответствовать шаблон: `[158]`. Результатом будет один символ из набора. Если же нужно найти любую цифру от 0 до 9, то легче использовать диапазон `[0-9]`, можно заметить, что такой диапазон соответствует специальному символу `\d`. 

```jsx live
function learnJavaScript() {
  let regExp = /[ban]/,
  str = '$bcd'
  return regExp.test(str) ? 'Нашёл' : 'Нету'
}
```

Так же мы можем задать `исключающий` диапазон символов, то есть те символы, которые не должны присутствовать в строке. Исключающий диапазон обозначается символом `^` в начале диапазона `[^...]`. К примеру, шаблон, исключающий любые цифры:
```jsx
let regExp = /[^0-9]/ // Аналог regExp = /\D/
```

## Квантификаторы

Квантификаторы используются для указания количества повторений определенных символов или целых наборов символов.

Квантификаторы в JavaScript:
#### `{n}` - указывает на **n** количество повторений шаблона или его части.
```jsx live
function learnJavaScript() {
  let regExp = /[0-9]{5}/, // аналог regExp = /\d{5}/
  str = '#$g99823'
  return regExp.test(str) ? 'Нашёл' : 'Нету'
}
```

Квантификатор `{n}` допускает и другие варианты использования:
- `{n, m} `в такой формате будут искаться повторения от n до m раз;
- `{n,}` в таком формате ищутся повторения от n до большего количества раз;

### Сокращенные квантификаторы
Сокращенные формы записи для востребованных квантификаторов:
1. `+` - **один или более**, тоже самое что и {1, }
2. `*` - **ноль или один**, тоже самое что и {0, 1}
3. `?` - **ноль или более**, тоже самое что и {0, }

## Группировка

Часть шаблона можно заключить в скобки `(...)` создав **скобочную группу**. Квантификаторы, используемые после скобок, применяются ко всей группе, а также совпавшую группу можно поместить в отдельный массив.

```jsx
let regExp = /(\w+)\s(\w+)/ 
// Строка "lime banana" будет соответствовать заданному шаблону
```

## Альтернация (или)

`Альтернация` – термин в регулярных выражениях, которому в русском языке соответствует слово **«ИЛИ»**.

В регулярных выражениях она обозначается символом вертикальной черты `|`.

```jsx live
  function learnJavaScript() {
    let regExp = /lime\s(orange|banana)/
    ,str = 'lime banana'
    return regExp.test(str) ? 'Нашёл' : 'Нету'
  }
```

## Методы класса String

### match
`str.match(regExp)` ищет совпадения шаблона `regExp` в строке `str`. <!-- Три режима работы метода: 1. Без флага `g`, метод возвращает первое совпадение в виде массива со скобочными группами, а так же свойствами `index` и `input`. `index` - позиция на которой было найдено совпадение. `input` - исходная строка, в которой осуществлялся поиск. 2. С флагом `g`, метод возвращает массив всех совпадений, без скобочных групп и других деталей. 3. Если совпадений нет, то возвращается `null`. -->
```jsx live
function learnJavaScript() {
  let str = 'lime banana orange'
  ,regExp = /banana/
  ,res = str.match(regExp)
  return res[0]
}
```

### split
`str.split(regExp)` разбивает строку `str` в массив по разделителю `regExp`.
```jsx live
function learnJavaScript() {
  let str = 'lime, banana, orange'
  ,regExp = /, /
  ,res= str.split(regExp)
  return res[1]
}
```

### search
`str.search(regExp)` возвращать позицию первого совпадения шаблона `regExp` в строке `str`, если в строке ничего не было найдено, то вернётся `-1`. У этого метода есть **ограничение**, он умеет возвращать только позицию **первого** совпадения.
```jsx live
function learnJavaScript() {
  let str = 'lime banana orange'
  ,regExp = /banana/
  ,res = str.search(regExp)
  return res
}
```

### replace
`str.replace(regExp, rep)` находит шаблон `regExp` в строке `str` и заменяет его на `rep`.
```jsx live
function learnJavaScript() {
  let str = 'lime banana orange'
  ,regExp = /orange/
  ,res = str.replace(regExp, 'pear')
  return res
}
```

## Метод класса RegExp

### exec
Метод `exec()` принимает параметром строку, а возвращает массив с результатами. У этого методу присутствуют свойства:
- `index` - номер позиции, на которой было найдено соответствие;
- `input` - исходная строка, в которой осуществлялся поиск.
```jsx live
function learnJavaScript() {
  let str = 'lime BANANA orange'
  ,regExp = /[A-Z]+/
  ,res = regExp.exec(str)
  return res[0]
}
```

### test
Метод `test()` принимает параметров строку, а возвращает `boolean` значение, обозначающее нахождение шаблона в строке.
```jsx live
function learnJavaScript() {
  let str = 'lime banana1 orange'
  ,regExp = /\w+\d/
  return regExp.test(str) ? 'Нашёл' : 'Нету'
}  
```

## Вопросы
1. Для чего нужны регулярные выражения?
  - создание шаблонов;
  - манипуляции со строками;
  - редактирования строк.

2. Какой символ используется для литерального создания регулярного выражения?
  - слэш `/`;
  - обратный слэш `\`;
  - квадратные скобки `[]`.

3. В каком способе создания регулярного выражения не допускается дальнейшее динамическое изменение задаваемых значений?
  - в Литеральном;
  - в Конструкторе;
  - при любом способе динамическое изменение допустимо.

4. Какой шаблон будет искать все совпадения в строке?
  - `/\w+/i`;
  - `new RegExp('banana', 'm')`;
  - `/banana/g`.

5. Каким образом в шаблоне обозначается специальный символ?
  - обратным слэшом `\`;
  - фигурными скобками `{}`;
  - слэшом `/`.

6. Чему соответствует специальный символ `.`?
  - символу табуляции;
  - любому символу;
  - цифре от 0 до 9.

7. Как проверить полное совпадение строки с шаблоном?
  - `/^(\w*)/`;
  - `/(\w*)$/`;
  - `/^(\w*)$/`.

8. Что будет искать в строке шаблон: `/[az]/`?
  - Символы от `a` до `z`;
  - Строку `az`;
  - Символ `a` или `z`.

9. Чему соответствует квантификатор `?`?
  - **ноль или более**;
  - **ноль или один**;
  - **один или более**.

10. Какому символу соответствует альтернация?
  - `*`;
  - `/`;
  - `|`.

## Ссылки
1. [Learn JavaScript](https://learn.javascript.ru/regular-expressions)
2. [MDN Web Docs](https://learn.javascript.ru/regular-expressions)
3. [JS RegExp](https://tuhub.ru/frontend/js-regexp)
=======
id: javascript28
title: Fetch API
sidebar_label: Fetch API
---

`Fetch API` позволяет JavaScript обмениваться данными с сервером с помощью HTTP-запросов и является более совершенной заменой классу `XMLHttpRequest`. Выполнение запросов осуществляется методом `fetch()`, который возвращает [Promise](https://react-native-village.github.io/docs/javascript24).

## Синтаксис

```jsx
let promise = fetch(url, [options])
```

- `url` - URL для отправки запроса;
- `options` - параметры запроса.

Задав метод `fetch()` без `options` вы получите GET-запрос, скачивающий данные по адресу `URL`.

## Параметры запроса

1. `method` - метод запроса (GET, POST, PUT, DELETE, HEAD);
2. `headers` - HTTP-заголовки;
3. `body` - тело запроса (используется при method: POST / PUT);
4. `cache` - режим кэширования (default, reload, no-cache);
5. `mode` - режим запроса (cors, no-cors, same-origin);
6. `redirect` - указывает, как обрабатывать перенаправления(follow, error, manual);
7. `referrer` - реферер запроса;
8. `signal` - AbortSignal, прерывание запроса;
9. `credentials` - отправка cookies вместе с запросом - mit, same-origin.

Пример запроса с методами

```jsx
fetch('https://example.com/', {
    method: 'GET',
    headers: {
        'Content-Type': 'application/json'
    }
}
```

## Получение ответа

Метод `fetch()` возвращает [Promise](https://react-native-village.github.io/docs/javascript24) объект класса `Response`, который имеет следующие свойства:

1. `status` - код ответа;
2. `statusText` - текстовое сообщение, соответствующее коду ответа;
3. `ok` - логическое значение, указывающее на успешность кода ответа (true: 200-299);
4. `headers` - объект с заголовками ответа, в котором ключ - наименование заголовка, а значение ключа - значение соответствующего ключу заголовка;
5. `url` - URL, на который был отправлен запрос;
6. `body` - данные ответа в формате `ReadableStream`
7. `bodyUsed` - логическое значение, указывающие на чтение данных.

## Обработка ответа

Переданные данные находятся в формате `ReadableStream`. Для изменения формата можно использовать следующие методы:

1. `text()` - преобразует ответ в строку;
2. `json()` - преобразует ответ в формате JSON;
3. `blob()` - преобразует ответ в объект Blob;
4. `formData()` - конвертируется ответ в экземпляр FormData;
5. `arrayBuffer()` - преобразует ответ в объект ArrayBuffer.

Пример преобразование ответа в формат JSON.

```jsx
let res = await fetch('https://example.com/') // Выполняем запрос
let com = await res.json() // Преобразовываем ответ
```

## Обработка ошибок

Узнать завершился ли `fetch()` с ошибкой мы можем с помощью свойств: "status" и "ok". Пример:

```jsx
let res = await fetch('https://example.com/') // Выполняем запрос

if (res.ok) {
  // Если HTTP-статус находится диапазоне 200-299
  let answer = await res.text() // Получаем ответ
} else {
  alert('Ошибка: ' + res.status) // Иначе выводим код ответа
}
```

## Примеры запросов

```jsx
fetch('https://example.com/api/data', {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      }
    }).then(response => {
      console.log(response.bodyUsed); // false
      let result = await response.json();
      console.log(response.bodyUsed); // true
      return result;
    });
```

Использование метода POST

```jsx
let response = await fetch('/article/fetch/post/user', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json;charset=utf-8'
  },
  body: JSON.stringify(user)
})

let result = await response.json()
alert(result.message)
```

Без `await`

```jsx
fetch('https://api.github.com/users/KrunalLathiya')
  .then((res) => res.json())
  .then((json) => console.log(json))
```

## Вопросы

1. Что возвращает метод `fetch()`?

- Функцию;
- Объект;
- Промисы.

2. Задав в `fetch()` только параметр URL, какой запрос мы получим?

- POST;
- GET;
- PUT.

3. Каким параметром указываются HTTP-заголовки?

- redirect;
- headers;
- credentials.

4. Какой метод нужно использовать для преобразование ответа в строку?

- blob();
- json();
- text().

5. Что означает свойство `ok` у объекта класса `Response`?

- Код ответа;
- Успешность кода ответа;
- Чтение данных из запроса;

## Ссылки

1. [Learn JavaScript](https://learn.javascript.ru/fetch)
2. [MDN Web Docs](https://developer.mozilla.org/ru/docs/Web/API/Fetch_API/Using_Fetch)
3. [JS Tutorial](https://www.javascripttutorial.net/javascript-fetch-api/)

## Contributors ✨

Thanks goes to these wonderful people ([emoji key](https://allcontributors.org/docs/en/emoji-key)):

<table>
  <tr> 
    <td align="center"><a href="https://github.com/IIo3iTiv"><img src="https://avatars1.githubusercontent.com/u/72025062?v=4?s=200" width="200px;" alt=""/><br /><sub><b>IIo3iTiv</b></sub></a><br /><a href="https://github.com/gHashTag/react-native-village/commits?author=IIo3iTiv" title="Documentation">📖</a></td>
    <td align="center"><a href="https://fullstackserverless.github.io/"><img src="https://avatars0.githubusercontent.com/u/6774813?v=4?s=200" width="200px;" alt=""/><br /><sub><b>Dmitriy Vasilev</b></sub></a><br /><a href="#financial-gHashTag" title="Financial">💵</a></td>
  </tr>
</table>

[![Become a Patron!](/img/logo/patreon.png)](https://www.patreon.com/bePatron?u=31769291)
